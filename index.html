<!doctype html>
<html dir="ltr" lang="en-US">
<head>
<title>langterm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<style type="text/css">
html, body {
  background: #222; color: #eee; margin: 0; overflow: hidden; width: 100%; height: 100%;
}
canvas { width: 100%; height: 100%; }
</style>
</head>
<body>

<canvas></canvas>

<script src="gl-matrix-min.js"></script>

<script id="bg-vs" type="x-shader/vertex">
attribute vec3 aPosition;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;

void main() {
  gl_Position = vec4(aPosition, 1.0);
  vTexCoord = aTexCoord;
}
</script>

<script id="bg-fs" type="x-shader/fragment">
uniform sampler2D uBGTex;
uniform vec2 uScreenSize;
uniform vec2 uBGSize;
varying mediump vec2 vTexCoord;

void main() {
  // An implementation of CSS background-size: cover
  // via http://stackoverflow.com/a/6565988 + my own crappy math
  vec2 s = uScreenSize; // Screen
  vec2 i = uBGSize; // Image
  float rs = s.x / s.y;
  float ri = i.x / i.y;
  vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
  vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
  vec2 uv = vTexCoord * s / new + offset;
  gl_FragColor = texture2D(uBGTex, uv);
}
</script>

<script id="post-vs" type="x-shader/vertex">
attribute vec3 aPosition;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;

void main() {
  gl_Position = vec4(aPosition, 1.0);
  vTexCoord = aTexCoord;
}
</script>

<script id="post-fs" type="x-shader/fragment">
uniform sampler2D uTermTex;
varying mediump vec2 vTexCoord;

// BEGIN -----------------------------------------------------------------------------

//
// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER
//
//   by Timothy Lottes
//
// This is more along the style of a really good CGA arcade monitor.
// With RGB inputs instead of NTSC.
// The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.
//
// Left it unoptimized to show the theory behind the algorithm.
//
// It is an example what I personally would want as a display option for pixel art games.
// Please take and use, change, or whatever.
//

vec2 iResolution = vec2(1024.0, 1024.0); // XXX

// Emulated input resolution.
#if 1
  // Fix resolution to set amount.
vec2 res = vec2(600.0 / 1.0, 240.0 / 1.0);
#else
  // Optimize for resize.
vec2 res = iResolution.xy / 6.0;
#endif

// Hardness of scanline.
//  -8.0 = soft
// -16.0 = medium
float hardScan = -8.0;

// Hardness of pixels in scanline.
// -2.0 = soft
// -4.0 = hard
float hardPix = -4.0;

// Display warp.
// 0.0 = none
// 1.0/8.0 = extreme
vec2 warp = vec2(1.0 / 60.0, 1.0 / 24.0);

// Amount of shadow mask.
float maskDark = 1.0;
float maskLight = 1.0;

// sRGB to Linear.
// Assuing using sRGB typed textures this should not be needed.
float ToLinear1(float c) {
  return (c <= 0.04045) ? c / 12.92 : pow((c + 0.055) / 1.055, 2.4);
}
vec3 ToLinear(vec3 c) {
  return vec3(ToLinear1(c.r), ToLinear1(c.g), ToLinear1(c.b));
}

// Linear to sRGB.
// Assuing using sRGB typed textures this should not be needed.
float ToSrgb1(float c) {
  return (c < 0.0031308 ? c * 12.92 : 1.055 * pow(c, 0.41666) - 0.055);
}
vec3 ToSrgb(vec3 c) {
  return vec3(ToSrgb1(c.r), ToSrgb1(c.g), ToSrgb1(c.b));
}

// Nearest emulated sample given floating point position and texel offset.
// Also zero's off screen.
vec3 Fetch(vec2 pos, vec2 off) {
  pos = floor(pos * res + off) / res;
  if (max(abs(pos.x - 0.5), abs(pos.y - 0.5)) > 0.5)
    return vec3(0.0, 0.0, 0.0);
  return ToLinear(texture2D(uTermTex, pos.xy, -16.0).rgb);
}

// Distance in emulated pixels to nearest texel.
vec2 Dist(vec2 pos) {
  pos = pos * res;
  return -((pos - floor(pos)) - vec2(0.5));
}

// 1D Gaussian.
float Gaus(float pos, float scale) {
  return exp2(scale * pos * pos);
}

// 3-tap Gaussian filter along horz line.
vec3 Horz3(vec2 pos, float off) {
  vec3 b = Fetch(pos, vec2(-1.0, off));
  vec3 c = Fetch(pos, vec2(0.0, off));
  vec3 d = Fetch(pos, vec2(1.0, off));
  float dst = Dist(pos).x;
  // Convert distance to weight.
  float scale = hardPix;
  float wb = Gaus(dst - 1.0, scale);
  float wc = Gaus(dst + 0.0, scale);
  float wd = Gaus(dst + 1.0, scale);
  // Return filtered sample.
  return (b * wb + c * wc + d * wd) / (wb + wc + wd);
}

// 5-tap Gaussian filter along horz line.
vec3 Horz5(vec2 pos, float off) {
  vec3 a = Fetch(pos, vec2(-2.0, off));
  vec3 b = Fetch(pos, vec2(-1.0, off));
  vec3 c = Fetch(pos, vec2(0.0, off));
  vec3 d = Fetch(pos, vec2(1.0, off));
  vec3 e = Fetch(pos, vec2(2.0, off));
  float dst = Dist(pos).x;
  // Convert distance to weight.
  float scale = hardPix;
  float wa = Gaus(dst - 2.0, scale);
  float wb = Gaus(dst - 1.0, scale);
  float wc = Gaus(dst + 0.0, scale);
  float wd = Gaus(dst + 1.0, scale);
  float we = Gaus(dst + 2.0, scale);
  // Return filtered sample.
  return (a * wa + b * wb + c * wc + d * wd + e * we) / (wa + wb + wc + wd + we);
}

// Return scanline weight.
float Scan(vec2 pos, float off) {
  float dst = Dist(pos).y;
  return Gaus(dst + off, hardScan);
}

// Allow nearest three lines to effect pixel.
vec3 Tri(vec2 pos) {
  vec3 a = Horz3(pos, -1.0);
  vec3 b = Horz5(pos, 0.0);
  vec3 c = Horz3(pos, 1.0);
  float wa = Scan(pos, -1.0);
  float wb = Scan(pos, 0.0);
  float wc = Scan(pos, 1.0);
  return a * wa + b * wb + c * wc;
}

// Distortion of scanlines, and end of screen alpha.
vec2 Warp(vec2 pos) {
  pos = pos * 2.0 - 1.0;
  pos *= vec2(1.0 + (pos.y * pos.y) * warp.x, 1.0 + (pos.x * pos.x) * warp.y);
  return pos * 0.5 + 0.5;
}

// Shadow mask.
vec3 Mask(vec2 pos) {
  pos.x += pos.y * 3.0;
  vec3 mask = vec3(maskDark, maskDark, maskDark);
  pos.x = fract(pos.x / 6.0);
  if (pos.x < 0.333)
    mask.r = maskLight;
  else if (pos.x < 0.666)
    mask.g = maskLight;
  else
    mask.b = maskLight;
  return mask;
}

// Draw dividing bars.
float Bar(float pos, float bar) {
  pos -= bar;
  return pos * pos < 4.0 ? 0.0 : 1.0;
}

// Entry.
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
  vec2 pos = Warp(fragCoord.xy / iResolution.xy);
  pos = Warp(fragCoord.xy / iResolution.xy);
  fragColor.rgb = Tri(pos) * Mask(fragCoord.xy);
  fragColor.a = fragColor.r; //1.0;
  fragColor.rgb = ToSrgb(fragColor.rgb);
}

// END -------------------------------------------------------------------------------

void main() {
  gl_FragColor = texture2D(uTermTex, vTexCoord);
  //gl_FragColor.b += 0.2; // XXX
  mainImage(gl_FragColor, vTexCoord*iResolution);
}

</script>

<script id="comp-vs" type="x-shader/vertex">
attribute vec3 aPosition;
attribute vec2 aTexCoord;
uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
varying vec2 vTexCoord;

void main() {
  gl_Position = uPMatrix * uMVMatrix * vec4(aPosition, 1.0);
  vTexCoord = aTexCoord;
}
</script>

<script id="comp-fs" type="x-shader/fragment">
uniform sampler2D uPostTex;
varying mediump vec2 vTexCoord;

void main() {
  gl_FragColor = texture2D(uPostTex, vTexCoord);
  if (vTexCoord.x < 0.01 || vTexCoord.x > 0.99 || vTexCoord.y < 0.01 || vTexCoord.y > 0.99) gl_FragColor += 0.2;
}
</script>

<script id="term-vs" type="x-shader/vertex">
uniform float uTime;
uniform vec2 uScreenSize;
uniform vec2 uGridSize;
attribute vec2 aGeo;
attribute vec2 aChar;
varying vec2 vCharCoord;
varying vec2 vArea;
varying float vAttr;

const float ATTR_CURSOR = 1.0;
const float ATTR_INVERSE = 2.0;
const float ATTR_BLINK = 4.0;

const float PADDING = 0.01;

void main() {
  // Geometry looks like this:
  //
  // ---------.
  // |    |  /
  // |    | /
  // |____|/
  // |    /
  // |   /
  // |  /
  // | /
  // |/

  // Char is our character space triangle vertex. (0,0) means first col & row.
  float i = aGeo[0];
  float row = floor(i/uGridSize.x);
  float col = i - row * uGridSize.x;
  vec2 char = vec2(col, row);
  float k = aGeo[1];
  if (k == 1.0) char.x += 1.0;
  if (k == 2.0) char.y += 1.0;

  // Area is also a similar triangle, but used by the fragment shader.
  vArea = vec2(0.0, 0.0);
  if (k == 1.0) vArea.x += 2.0;
  if (k == 2.0) vArea.y += 2.0;

  // Pos converts the char coords to clip space.
  vec2 pos = char;
  if (k == 1.0) pos.x += 1.3; // 1.0 works but these values result in
  if (k == 2.0) pos.y += 0.7; // some better line spacing.
  pos = (pos / uGridSize * 2.0) - 1.0;
  pos *= (1.0 - PADDING * 2.0) + PADDING;
  pos.y *= -1.0;
  gl_Position = vec4(pos, 0, 1);

  // The second item of aChar is a bitmask of character attributes.
  vAttr = aChar[1];

  // Calculate the 128x128px (16x16 grid) Apple 2 sprite map coords.
  i = aChar[0] - 32.0;
  col = mod(i, 16.0) / 16.0;
  row = floor(i/16.0) / 16.0;
  // If this char is the cursor, make it blink the cursor symbol.
  if (mod(vAttr / ATTR_CURSOR, 2.0) >= 1.0 && mod(uTime*3.5, 2.0) <= 1.0) {
    col = 15.0/16.0;
    row = 5.0/16.0;
  }
  vCharCoord = vec2(col, row);
  // Remember, make a triangle, and make large enough to cover the character rectangle.
  if (k == 1.0) vCharCoord.x += 2.0/16.0;
  if (k == 2.0) vCharCoord.y += 2.0/16.0;
}
</script>

<script id="term-fs" type="x-shader/fragment">
uniform float uTime;
uniform sampler2D uFont;
varying vec2 vCharCoord;
varying vec2 vArea;
varying float vAttr;

const float ATTR_CURSOR = 1.0;
const float ATTR_INVERSE = 2.0;
const float ATTR_BLINK = 4.0;

const vec4 FG = vec4(.95, .45, .02, 1.0);

const float EPSILON = 0.000;

void main() {
  // Trim the triangle so we only draw the rectangle.
  // Without EPSILON we get a few gaps in inversed lines.
  if (vArea.x > 1.0 + EPSILON || vArea.y > 1.0 + EPSILON) discard;

  bool value = texture2D(uFont, vCharCoord).r >= 1.0;
  bool inverse = mod(vAttr / ATTR_INVERSE, 2.0) >= 1.0;
  if (value && inverse) discard;
  if (!value && !inverse) discard;

  gl_FragColor = FG;
}
</script>

<script>

var Terminal = (function() {

  function Terminal() {
    this.width = 60;
    this.height = 24;
    this.cursor = { x: 0, y: 0 };
    var a = this.width * this.height;
    this.buffer = new Array(a);
    this.attrs = new Array(a);
    this._charBuffer = new Float32Array(a * 6);
    this._geoBuffer = new Float32Array(a * 6);
    this.clear();
  }

  Terminal.ATTR_CURSOR = 1;
  Terminal.ATTR_INVERSE = 2;
  Terminal.ATTR_BLINK = 4;

  Terminal.prototype.clear = function() {
    this.cursor.x = 0;
    this.cursor.y = 0;
    for (var i = 0, len = this.buffer.length; i < len; i++) {
      this.buffer[i] = ' ';
      this.attrs[i] = 0;
    }
    this._dirty = true;
  };

  Terminal.prototype.addString = function(s, attrs) {
    var _this = this;
    s.split('').forEach(function(c) { _this.addChar(c, attrs); });
  };

  Terminal.prototype.addChar = function(c, attrs) {
    var i = this.cursor.y * this.width + this.cursor.x;
    if (c !== '\n') {
      this.buffer[i] = c;
      this.attrs[i] = attrs || 0;
    }
    if (c === '\n' || this.cursor.x >= this.width - 1) {
      this.cursor.x = 0;
      this.cursor.y++;
    } else {
      this.cursor.x++;
    }
    if (this.cursor.y >= this.height) {
      this.cursor.y--;
      var lastLine = this.buffer.length - this.width;
      for (i = 0, len = this.buffer.length; i < len; i++) {
        if (i < lastLine) {
          this.buffer[i] = this.buffer[i + this.width];
          this.attrs[i] = this.attrs[i + this.width];
        } else {
          this.buffer[i] = ' ';
          this.attrs[i] = 0;
        }
      }
    }
    this._dirty = true;
  };

  Terminal.prototype._update = function() {
    if (!this._dirty) return;
    for (var i = 0, len = this.buffer.length; i < len; i++) {
      var j = i * 6, c = this.buffer[i].charCodeAt(0), a = this.attrs[i];
      var y = Math.floor(i / this.width), x = i - y * this.width;
      if (this.cursor.x === x && this.cursor.y === y) a |= Terminal.ATTR_CURSOR;
      this._charBuffer[j+0] = c;
      this._charBuffer[j+1] = a;
      this._charBuffer[j+2] = c;
      this._charBuffer[j+3] = a;
      this._charBuffer[j+4] = c;
      this._charBuffer[j+5] = a;
      this._geoBuffer[j+0] = i;
      this._geoBuffer[j+1] = 0;
      this._geoBuffer[j+2] = i;
      this._geoBuffer[j+3] = 1;
      this._geoBuffer[j+4] = i;
      this._geoBuffer[j+5] = 2;
    }
  };

  Terminal.prototype.getCharBuffer = function() {
    this._update();
    return this._charBuffer;
  };

  Terminal.prototype.getGeoBuffer = function() {
    this._update();
    return this._geoBuffer;
  };

  Terminal.prototype.toString = function() {
    var out = new Array(this.buffer.length);
    for (var i = 0, len = this.buffer.length; i < len; i++) {
      out[i] = this.buffer[i] + (i !== 0 && i % this.width == 0 ? '\n' : '');
    }
    return out.join('');
  };

  return Terminal;

})();

var term = new Terminal();
term.addString(
"     __ _____________  __  ___                \n" +
"    / //_  __/ __/ _ \\/  |/  / 28.8k bps \\o/\n" +
"   / /__/ / / _// , _/ /|_/ /  vLink 1.359    \n" +
"  /____/_/ /___/_/|_/_/  /_/   617-555-1337   \n" +
"                                              \n" +
"Username: ian                                 \n" +
"Password: **********                          \n" +
"logging in....................                \n" +
"Welcome session b6623a0fcc38cf68              \n" +
"Type 'help' to get started                    \n" +
">");
//for (var i = 0; i < term.width * term.height - 2; i++) { term.addChar('#'); }

(function() {
  window.addEventListener('keydown', function(e) {
    if (e.key.length === 1) term.addChar(e.key);
    else if (e.keyCode === 13) term.addChar('\n');
    else return;
    gl.bindBuffer(gl.ARRAY_BUFFER, geoBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, term.getGeoBuffer(), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, term.getCharBuffer(), gl.STATIC_DRAW);
  });
  window.focus();
})();

/**
 * Provides requestAnimationFrame in a cross browser way.
 * paulirish.com/2011/requestanimationframe-for-smart-animating/
 */
window.requestAnimationFrame = window.requestAnimationFrame || (function() {
  return window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback, element) {
      window.setTimeout(callback, 1000 / 60);
    };
})();

var canvas,
  gl,
  geoBuffer,
  charBuffer,
  charLocation,
  fontTex, fontTexLocation,
  bgTex, bgTexLocation,
  termTex, termFrameBuf,
  termProgram,
  geoLocation,
  timeLocation,
  screenSizeLocation,
  screenSize2Location,
  bgSizeLocation,
  gridSizeLocation,
  compProgram,
  compPostTexLocation,
  compPositionBuffer, compPositionLocation,
  compTexCoordBuffer, compTexCoordLocation,
  compMVMatrix, compMVMatrixLocation,
  compPMatrix, compPMatrixLocation,
  postProgram,
  postFrameBuf, postTex, postTermTexLocation,
  postPositionBuffer, postPositionLocation,
  postTexCoordBuffer, postTexCoordLocation,
  bgProgram,
  bgImageTexLocation,
  bgPositionBuffer, bgPositionLocation,
  bgTexCoordBuffer, bgTexCoordLocation,
  parameters = {
    start_time: Date.now(),
    time: 0,
    screenWidth: 0,
    screenHeight: 0,
    gridWidth: term.width,
    gridHeight: term.height
  };

var fontImage = new Image();
fontImage.src = 'apple2font.png';
var bgImage = new Image();
bgImage.src = 'term.jpg';
var barrier = 0;
bgImage.onload = fontImage.onload = function() {
  barrier++;
  if (barrier === 2) {
    init();
    animate();
  }
};

function init() {
  glMatrix.setMatrixArrayType(Float32Array);

  var UNIT_QUAD_GEO = new Float32Array([
     1.0,  1.0,  0.0,
    -1.0,  1.0,  0.0,
     1.0, -1.0,  0.0,
    -1.0, -1.0,  0.0
  ]);
  var UNIT_QUAT_COORDS = new Float32Array([
    1, 1,
    0, 1,
    1, 0,
    0, 0
  ]);

  var vs, fs;
  canvas = document.querySelector('canvas');

  try {
    gl = canvas.getContext('experimental-webgl');
  } catch (error) {}
  if (!gl) {
    throw "Cannot create WebGL context.";
  }

  // Terminal gemoetry buffer
  geoBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, geoBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, term.getGeoBuffer(), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Terminal character buffer
  charBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, term.getCharBuffer(), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Terminal font image
  fontTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, fontTex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, fontImage);
  gl.bindTexture(gl.TEXTURE_2D, null);

  // Terminal shader
  vs = document.getElementById('term-vs').textContent;
  fs = document.getElementById('term-fs').textContent;
  termProgram = createProgram(vs, fs);
  timeLocation = gl.getUniformLocation(termProgram, 'uTime');
  screenSizeLocation = gl.getUniformLocation(termProgram, 'uScreenSize');
  gridSizeLocation = gl.getUniformLocation(termProgram, 'uGridSize');
  fontTexLocation = gl.getUniformLocation(termProgram, 'uFont');
  geoLocation = gl.getAttribLocation(termProgram, 'aGeo');
  charLocation = gl.getAttribLocation(termProgram, 'aChar');

  // Terminal framebuffer & texture
  termFrameBuf = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, termFrameBuf);
  termTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, termTex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1024, 1024, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, termTex, 0);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  // Post-process framebuffer & texture
  postFrameBuf = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, postFrameBuf);
  postTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, postTex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1024, 1024, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, postTex, 0);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  // Post-process geometry buffer
  postPositionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, postPositionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, UNIT_QUAD_GEO, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Post-process texture coordinate buffer
  postTexCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, postTexCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, UNIT_QUAT_COORDS, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Post-process shader
  vs = document.getElementById('post-vs').textContent;
  fs = document.getElementById('post-fs').textContent;
  postProgram = createProgram(vs, fs);
  postTermTexLocation = gl.getUniformLocation(postProgram, 'uTermTex');
  postPositionLocation = gl.getAttribLocation(postProgram, 'aPosition');
  postTexCoordLocation = gl.getAttribLocation(postProgram, 'aTexCoord');

  // Composition geometry buffer
  compPositionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, compPositionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, UNIT_QUAD_GEO, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Composition texture coordinate buffer
  compTexCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, compTexCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, UNIT_QUAT_COORDS, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Composition shader
  vs = document.getElementById('comp-vs').textContent;
  fs = document.getElementById('comp-fs').textContent;
  compProgram = createProgram(vs, fs);
  compMVMatrixLocation = gl.getUniformLocation(compProgram, 'uMVMatrix');
  compPMatrixLocation = gl.getUniformLocation(compProgram, 'uPMatrix');
  compPostTexLocation = gl.getUniformLocation(compProgram, 'uPostTex');
  compPositionLocation = gl.getAttribLocation(compProgram, 'aPosition');
  compTexCoordLocation = gl.getAttribLocation(compProgram, 'aTexCoord');

  // Background image
  bgTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, bgTex);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bgImage);
  gl.bindTexture(gl.TEXTURE_2D, null);

  // Background geometry buffer
  bgPositionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgPositionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, UNIT_QUAD_GEO, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Background texture coordinate buffer
  bgTexCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bgTexCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, UNIT_QUAT_COORDS, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Background shader
  vs = document.getElementById('bg-vs').textContent;
  fs = document.getElementById('bg-fs').textContent;
  bgProgram = createProgram(vs, fs);
  bgImageTexLocation = gl.getUniformLocation(bgProgram, 'uBGTex');
  screenSize2Location = gl.getUniformLocation(bgProgram, 'uScreenSize');
  bgSizeLocation = gl.getUniformLocation(bgProgram, 'uBGSize');
  bgPositionLocation = gl.getAttribLocation(bgProgram, 'aPosition');
  bgTexCoordLocation = gl.getAttribLocation(bgProgram, 'aTexCoord');

}

function createProgram(vertex, fragment) {
  var program = gl.createProgram();
  var preamble = '#ifdef GL_ES\nprecision mediump float;\n#endif\n\n';
  var vs = createShader(preamble + vertex, gl.VERTEX_SHADER);
  var fs = createShader(preamble + fragment, gl.FRAGMENT_SHADER);

  if (vs == null || fs == null) return null;
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.deleteShader(vs);
  gl.deleteShader(fs);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error("ERROR:\n" +
      "VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n" +
      "ERROR: " + gl.getError() + "\n" +
      "LOG: " + gl.getProgramInfoLog(program) + "\n\n" +
      "- Vertex Shader -\n" + vertex + "\n\n" +
      "- Fragment Shader -\n" + fragment);
    return null;
  }

  return program;
}

function createShader(src, type) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error((type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT") + " SHADER:\n" + gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}

function resize() {
  var r = window.devicePixelRatio || 1;
  var w = Math.floor(gl.canvas.clientWidth  * r);
  var h = Math.floor(gl.canvas.clientHeight * r);
  if (canvas.width != w || canvas.height != h) {
    canvas.width = parameters.screenWidth = w;
    canvas.height = parameters.screenHeight = h;
  }
  compPMatrix = mat4.create();
  mat4.perspective(compPMatrix, Math.PI/4, w/h, .1, 100);
  compMVMatrix = mat4.create();
  var q = quat.create();
  quat.rotateY(q, q, glMatrix.toRadian(6));
  quat.rotateZ(q, q, glMatrix.toRadian(1));
  mat4.fromRotationTranslationScale(compMVMatrix, q, [0.20, 0.05, -4.2], [1.45, 1.05, 1]);
}

function animate() {
  resize();
  render();
  requestAnimationFrame(animate);
}

function render() {
  if (!termProgram) return;

  // Draw the terminal

  parameters.time = Date.now() - parameters.start_time;

  gl.bindFramebuffer(gl.FRAMEBUFFER, termFrameBuf);
  gl.viewport(0, 0, 1024, 1024);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.useProgram(termProgram);
  gl.uniform1f(timeLocation, parameters.time / 1000);
  gl.uniform2f(screenSizeLocation, parameters.screenWidth, parameters.screenHeight);
  gl.uniform2f(gridSizeLocation, parameters.gridWidth, parameters.gridHeight);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, fontTex);
  gl.uniform1i(fontTexLocation, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, geoBuffer);
  gl.vertexAttribPointer(geoLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(geoLocation);

  gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
  gl.vertexAttribPointer(charLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(charLocation);

  gl.drawArrays(gl.TRIANGLES, 0, term.buffer.length * 3);

  gl.disableVertexAttribArray(geoLocation);
  gl.disableVertexAttribArray(charLocation);

  gl.bindTexture(gl.TEXTURE_2D, termTex);
  gl.generateMipmap(gl.TEXTURE_2D);
  gl.bindTexture(gl.TEXTURE_2D, null);

  // Post-process the terminal

  gl.bindFramebuffer(gl.FRAMEBUFFER, postFrameBuf);
  gl.viewport(0, 0, 1024, 1024);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.useProgram(postProgram);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, termTex);
  gl.uniform1i(postTermTexLocation, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, postPositionBuffer);
  gl.vertexAttribPointer(postPositionLocation, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(postPositionLocation);

  gl.bindBuffer(gl.ARRAY_BUFFER, postTexCoordBuffer);
  gl.vertexAttribPointer(postTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(postTexCoordLocation);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  gl.bindTexture(gl.TEXTURE_2D, postTex);
  gl.generateMipmap(gl.TEXTURE_2D);
  gl.bindTexture(gl.TEXTURE_2D, null);

  gl.disableVertexAttribArray(postPositionLocation);
  gl.disableVertexAttribArray(postTexCoordLocation);

  // Draw the background

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.useProgram(bgProgram);
  gl.uniform2f(screenSize2Location, parameters.screenWidth, parameters.screenHeight);
  gl.uniform2f(bgSizeLocation, bgImage.width, bgImage.height);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, bgTex);
  gl.uniform1i(bgImageTexLocation, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, bgPositionBuffer);
  gl.vertexAttribPointer(bgPositionLocation, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(bgPositionLocation);

  gl.bindBuffer(gl.ARRAY_BUFFER, bgTexCoordBuffer);
  gl.vertexAttribPointer(bgTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(bgTexCoordLocation);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  gl.disableVertexAttribArray(bgPositionLocation);
  gl.disableVertexAttribArray(bgTexCoordLocation);

  // Composite the terminal

  gl.useProgram(compProgram);
  gl.uniformMatrix4fv(compMVMatrixLocation, false, compMVMatrix);
  gl.uniformMatrix4fv(compPMatrixLocation, false, compPMatrix);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, postTex);
  gl.uniform1i(compPostTexLocation, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, compPositionBuffer);
  gl.vertexAttribPointer(compPositionLocation, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(compPositionLocation);

  gl.bindBuffer(gl.ARRAY_BUFFER, compTexCoordBuffer);
  gl.vertexAttribPointer(compTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(compTexCoordLocation);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  gl.disableVertexAttribArray(compPositionLocation);
  gl.disableVertexAttribArray(compTexCoordLocation);

}

</script>
</body>
</html>
