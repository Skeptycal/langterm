<!doctype html>
<!--

     __ _____________  __  ___
    / //_  __/ __/ _ \/  |/  / 28.8k bps \o/
   / /__/ / / _// , _/ /|_/ /  vLink 1.359
  /____/_/ /___/_/|_/_/  /_/   617-555-1337

Username: ian
Password: **********
logging in....................
Welcome session b6623a0fcc38cf68
Type 'help' to get started
>

-->
<html dir="ltr" lang="en-US">
<head>
<title>langterm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<style type="text/css">
html, body { background: #222; color: #eee; margin: 0; overflow: hidden; width: 100%; height: 100%; }
canvas { width: 100%; height: 100%; }
</style>
</head>
<body>

<canvas></canvas>

<script src="gl-matrix-min.js"><</script>

<script id="vs" type="x-shader/vertex">
uniform vec2 uScreenSize;
uniform vec2 uGridSize;
attribute vec2 aPosition;
attribute float aChar;
varying vec2 vCharCoord;
varying vec2 vArea;

const float padding = 0.1;

void main() {
  float k = aPosition.y;
  vec2 char = vec2(aPosition.x, 0);
  if (k == 1.0) char.x += 1.0;
  if (k == 2.0) char.y += 1.0;

  vec2 pos = char;
  if (k == 1.0) pos.x += 1.0;
  if (k == 2.0) pos.y += 1.0;
  pos *= (1.0 - padding * 2.0) + padding;
  pos = (pos / uGridSize * 2.0) - 1.0;
  pos.y *= -1.0;
  gl_Position = vec4(pos, 0, 1);

  float i = aChar - 32.0;
  float col = mod(i, 16.0) / 16.0;
  float row = floor(i/16.0) / 16.0;
  vCharCoord = vec2(col, row);
  if (k == 1.0) vCharCoord.x += 2.0/16.0;
  if (k == 2.0) vCharCoord.y += 2.0/16.0;

  vArea = vec2(0.0, 0.0);
  if (k == 1.0) vArea.x += 2.0;
  if (k == 2.0) vArea.y += 2.0;
}
</script>

<script id="fs" type="x-shader/fragment">
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform sampler2D uImage;
varying vec2 vCharCoord;
varying vec2 vArea;

void main() {
  vec4 color = texture2D(uImage, vCharCoord);
  if (color.r < 0.9) discard;
  if (vArea.x > 1.0 || vArea.y > 1.0) discard;
  gl_FragColor = color;
}
</script>

<script>

var Terminal = (function() {

  function Terminal() {
    this.width = 40;
    this.height = 24;
    this.cursor = { x: 0, y: 0 };
    var a = this.width * this.height;
    this.buffer = new Array(a);
    this._charBuffer = new Float32Array(a * 3);
    this._geoBuffer = new Float32Array(a * 6);
    this.clear();
  }

  Terminal.prototype.clear = function() {
    this.cursor.x = 0;
    this.cursor.y = 0;
    for (var i = 0, len = this.buffer.length; i < len; i++) {
      this.buffer[i] = ' ';
    }
    this._dirty = true;
  };

  Terminal.prototype.addString = function(s) {
    s.split('').forEach(this.addChar.bind(this));
  };

  Terminal.prototype.addChar = function(c) {
    this.buffer[this.cursor.y * this.width + this.cursor.x] = c;
    if (this.cursor >= this.width - 1) {
      this.cursor.x = 0;
      this.cursor.y++;
    } else {
      this.cursor.x++;
    }
    if (this.cursor.y >= this.width) {
      this.cursor.y--;
      var lastLine = this.buffer.length - this.width;
      for (var i = 0, len = this.buffer.length; i < len; i++) {
        if (i < lastLine) {
          this.buffer[i] = this.buffer[i + this.width];
        } else {
          this.buffer[i] = ' ';
        }
      }
    }
    this._dirty = true;
  };

  Terminal.prototype._update = function() {
    if (!this._dirty) return;
    for (var i = 0, len = this.buffer.length; i < len; i++) {
      var j = i * 3, c = this.buffer[i].charCodeAt(0);
      this._charBuffer[j+0] = c;
      this._charBuffer[j+1] = c;
      this._charBuffer[j+2] = c;
      j = i * 6;
      this._geoBuffer[j+0] = i;
      this._geoBuffer[j+1] = 0;
      this._geoBuffer[j+2] = i;
      this._geoBuffer[j+3] = 1;
      this._geoBuffer[j+4] = i;
      this._geoBuffer[j+5] = 2;
    }
  };

  Terminal.prototype.getCharBuffer = function() {
    this._update();
    return this._charBuffer;
  };

  Terminal.prototype.getGeoBuffer = function() {
    this._update();
    return this._geoBuffer;
  };

  Terminal.prototype.toString = function() {
    var out = new Array(this.buffer.length);
    for (var i = 0, len = this.buffer.length; i < len; i++) {
      out[i] = this.buffer[i] + (i !== 0 && i % this.width == 0 ? '\n' : '');
    }
    return out.join('');
  };

  return Terminal;

})();

var term = new Terminal();
term.addString('hello!*');

(function() {
  window.addEventListener('keydown', function(e) {
    if (!(e.altKey || e.ctrlKey || e.metaKey) && e.key !== 'Shift') term.addChar(e.key);
    //console.log(e.key);
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, term.getGeoBuffer(), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, term.getCharBuffer(), gl.STATIC_DRAW);
  });
  window.focus();
})();

/**
 * Provides requestAnimationFrame in a cross browser way.
 * paulirish.com/2011/requestanimationframe-for-smart-animating/
 */
window.requestAnimationFrame = window.requestAnimationFrame || (function() {
  return window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback, element) {
      window.setTimeout(callback, 1000 / 60);
    };
})();

var canvas,
  gl,
  buffer,
  charBuffer,
  charLocation,
  vertex_shader, fragment_shader,
  currentProgram,
  positionLocation,
  timeLocation,
  screenSizeLocation,
  gridSizeLocation,
  parameters = {
    start_time: new Date().getTime(),
    time: 0,
    screenWidth: 0,
    screenHeight: 0,
    gridWidth: 20,
    gridHeight: 20
  };

var image = new Image();
image.src = 'apple2font.png';
image.onload = function() {
  init();
  animate();
};

function init() {
  vertex_shader = document.getElementById('vs').textContent;
  fragment_shader = document.getElementById('fs').textContent;

  canvas = document.querySelector('canvas');

  try {
    gl = canvas.getContext('experimental-webgl');
  } catch (error) {}
  if (!gl) {
    throw "Cannot create WebGL context.";
  }

  buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, term.getGeoBuffer(), gl.STATIC_DRAW);

  charBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, term.getCharBuffer(), gl.STATIC_DRAW);

  // Font image
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

  // Create Program
  currentProgram = createProgram(vertex_shader, fragment_shader);
  timeLocation = gl.getUniformLocation(currentProgram, 'time');
  screenSizeLocation = gl.getUniformLocation(currentProgram, 'uScreenSize');
  gridSizeLocation = gl.getUniformLocation(currentProgram, 'uGridSize');
  positionLocation = gl.getAttribLocation(currentProgram, 'aPosition');
  charLocation = gl.getAttribLocation(currentProgram, 'aChar');
}

function createProgram(vertex, fragment) {

  var program = gl.createProgram();

  var vs = createShader(vertex, gl.VERTEX_SHADER);
  var fs = createShader(fragment, gl.FRAGMENT_SHADER);

  if (vs == null || fs == null) return null;

  gl.attachShader(program, vs);
  gl.attachShader(program, fs);

  gl.deleteShader(vs);
  gl.deleteShader(fs);

  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {

    throw new Error("ERROR:\n" +
      "VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n" +
      "ERROR: " + gl.getError() + "\n" +
      "LOG: " + gl.getProgramInfoLog(program) + "\n\n" +
      "- Vertex Shader -\n" + vertex + "\n\n" +
      "- Fragment Shader -\n" + fragment);

    return null;

  }

  return program;

}

function createShader(src, type) {

  var shader = gl.createShader(type);

  gl.shaderSource(shader, src);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {

    throw new Error((type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT") + " SHADER:\n" + gl.getShaderInfoLog(shader));
    return null;

  }

  return shader;

}

function resize() {
  var r = window.devicePixelRatio || 1;
  var w = Math.floor(gl.canvas.clientWidth  * r);
  var h = Math.floor(gl.canvas.clientHeight * r);
  if (canvas.width != w || canvas.height != h) {
    canvas.width = parameters.screenWidth = w;
    canvas.height = parameters.screenHeight = h;
    gl.viewport(0, 0, w, h);
  }
}

function animate() {
  resize();
  render();
  requestAnimationFrame(animate);
}

function render() {

  if (!currentProgram) return;

  parameters.time = Date.now() - parameters.start_time;

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Load program into GPU
  gl.useProgram(currentProgram);

  // Set values to program variables
  gl.uniform1f(timeLocation, parameters.time / 1000);
  gl.uniform2f(screenSizeLocation, parameters.screenWidth, parameters.screenHeight);
  gl.uniform2f(gridSizeLocation, parameters.gridWidth, parameters.gridHeight);

  // Render geometry
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(positionLocation);

  gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
  gl.vertexAttribPointer(charLocation, 1, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(charLocation);

  gl.drawArrays(gl.TRIANGLES, 0, term.buffer.length * 3);

  gl.disableVertexAttribArray(positionLocation);
  gl.disableVertexAttribArray(charLocation);

}

</script>
</body>
</html>
