<!doctype html>
<html dir="ltr" lang="en-US">
<head>
<title>langterm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<style type="text/css">
html, body {
  background: #222; color: #eee; margin: 0; overflow: hidden; width: 100%; height: 100%;
  XXXbackground-image: url('term.jpg');
  background-size: cover;
  background-position: center;
}
canvas { width: 100%; height: 100%; }
</style>
</head>
<body>

<canvas></canvas>

<script src="gl-matrix-min.js"><</script>

<script id="vs" type="x-shader/vertex">
#ifdef GL_ES
precision mediump float;
#endif

uniform float uTime;
uniform vec2 uScreenSize;
uniform vec2 uGridSize;
attribute vec2 aGeo;
attribute vec2 aChar;
varying vec2 vCharCoord;
varying vec2 vArea;
varying float vAttr;

const float ATTR_CURSOR = 1.0;
const float ATTR_INVERSE = 2.0;
const float ATTR_BLINK = 4.0;

const float PADDING = 0.1;

void main() {
  // Geometry looks like this:
  //
  // ---------.
  // |    |  /
  // |    | /
  // |____|/
  // |    /
  // |   /
  // |  /
  // | /
  // |/

  // Char is our character space triangle vertex. (0,0) means first col & row.
  float i = aGeo[0];
  float row = floor(i/uGridSize.x);
  float col = i - row * uGridSize.x;
  vec2 char = vec2(col, row);
  float k = aGeo[1];
  if (k == 1.0) char.x += 1.0;
  if (k == 2.0) char.y += 1.0;

  // Area is also a similar triangle, but used by the fragment shader.
  vArea = vec2(0.0, 0.0);
  if (k == 1.0) vArea.x += 2.0;
  if (k == 2.0) vArea.y += 2.0;

  // Pos converts the char coords to clip space.
  vec2 pos = char;
  if (k == 1.0) pos.x += 1.3; // 1.0 works but these values result in
  if (k == 2.0) pos.y += 0.7; // some better line spacing.
  pos = (pos / uGridSize * 2.0) - 1.0;
  pos *= (1.0 - PADDING * 2.0) + PADDING;
  pos.y *= -1.0;
  gl_Position = vec4(pos, 0, 1);

  // The second item of aChar is a bitmask of character attributes.
  vAttr = aChar[1];

  // Calculate the 128x128px (16x16 grid) Apple 2 sprite map coords.
  i = aChar[0] - 32.0;
  col = mod(i, 16.0) / 16.0;
  row = floor(i/16.0) / 16.0;
  // If this char is the cursor, make it blink the cursor symbol.
  if (mod(vAttr / ATTR_CURSOR, 2.0) >= 1.0 && mod(uTime*3.5, 2.0) <= 1.0) {
    col = 15.0/16.0;
    row = 5.0/16.0;
  }
  vCharCoord = vec2(col, row);
  // Remember, make a triangle, and make large enough to cover the character rectangle.
  if (k == 1.0) vCharCoord.x += 2.0/16.0;
  if (k == 2.0) vCharCoord.y += 2.0/16.0;
}
</script>

<script id="fs" type="x-shader/fragment">
#ifdef GL_ES
precision mediump float;
#endif

uniform float uTime;
uniform sampler2D uFont;
varying vec2 vCharCoord;
varying vec2 vArea;
varying float vAttr;

const float ATTR_CURSOR = 1.0;
const float ATTR_INVERSE = 2.0;
const float ATTR_BLINK = 4.0;

const vec4 FG = vec4(.95, .45, .02, 1.0);

const float EPSILON = 0.000;

void main() {
  // Trim the triangle so we only draw the rectangle.
  // Without EPSILON we get a few gaps in inversed lines.
  if (vArea.x > 1.0 + EPSILON || vArea.y > 1.0 + EPSILON) discard;

  bool value = texture2D(uFont, vCharCoord).r >= 1.0;
  bool inverse = mod(vAttr / ATTR_INVERSE, 2.0) >= 1.0;
  if (value && inverse) discard;
  if (!value && !inverse) discard;

  gl_FragColor = FG;
}
</script>

<script>

var Terminal = (function() {

  function Terminal() {
    this.width = 60;
    this.height = 50;
    this.cursor = { x: 0, y: 0 };
    var a = this.width * this.height;
    this.buffer = new Array(a);
    this.attrs = new Array(a);
    this._charBuffer = new Float32Array(a * 6);
    this._geoBuffer = new Float32Array(a * 6);
    this.clear();
  }

  Terminal.ATTR_CURSOR = 1;
  Terminal.ATTR_INVERSE = 2;
  Terminal.ATTR_BLINK = 4;

  Terminal.prototype.clear = function() {
    this.cursor.x = 0;
    this.cursor.y = 0;
    for (var i = 0, len = this.buffer.length; i < len; i++) {
      this.buffer[i] = ' ';
      this.attrs[i] = 0;
    }
    this._dirty = true;
  };

  Terminal.prototype.addString = function(s, attrs) {
    var _this = this;
    s.split('').forEach(function(c) { _this.addChar(c, attrs); });
  };

  Terminal.prototype.addChar = function(c, attrs) {
    var i = this.cursor.y * this.width + this.cursor.x;
    if (c !== '\n') {
      this.buffer[i] = c;
      this.attrs[i] = attrs || 0;
    }
    if (c === '\n' || this.cursor.x >= this.width - 1) {
      this.cursor.x = 0;
      this.cursor.y++;
    } else {
      this.cursor.x++;
    }
    if (this.cursor.y >= this.height) {
      this.cursor.y--;
      var lastLine = this.buffer.length - this.width;
      for (i = 0, len = this.buffer.length; i < len; i++) {
        if (i < lastLine) {
          this.buffer[i] = this.buffer[i + this.width];
          this.attrs[i] = this.attrs[i + this.width];
        } else {
          this.buffer[i] = ' ';
          this.attrs[i] = 0;
        }
      }
    }
    this._dirty = true;
  };

  Terminal.prototype._update = function() {
    if (!this._dirty) return;
    for (var i = 0, len = this.buffer.length; i < len; i++) {
      var j = i * 6, c = this.buffer[i].charCodeAt(0), a = this.attrs[i];
      var y = Math.floor(i / this.width), x = i - y * this.width;
      if (this.cursor.x === x && this.cursor.y === y) a |= Terminal.ATTR_CURSOR;
      this._charBuffer[j+0] = c;
      this._charBuffer[j+1] = a;
      this._charBuffer[j+2] = c;
      this._charBuffer[j+3] = a;
      this._charBuffer[j+4] = c;
      this._charBuffer[j+5] = a;
      this._geoBuffer[j+0] = i;
      this._geoBuffer[j+1] = 0;
      this._geoBuffer[j+2] = i;
      this._geoBuffer[j+3] = 1;
      this._geoBuffer[j+4] = i;
      this._geoBuffer[j+5] = 2;
    }
  };

  Terminal.prototype.getCharBuffer = function() {
    this._update();
    return this._charBuffer;
  };

  Terminal.prototype.getGeoBuffer = function() {
    this._update();
    return this._geoBuffer;
  };

  Terminal.prototype.toString = function() {
    var out = new Array(this.buffer.length);
    for (var i = 0, len = this.buffer.length; i < len; i++) {
      out[i] = this.buffer[i] + (i !== 0 && i % this.width == 0 ? '\n' : '');
    }
    return out.join('');
  };

  return Terminal;

})();

var term = new Terminal();
term.addString(
"     __ _____________  __  ___                \n" +
"    / //_  __/ __/ _ \\/  |/  / 28.8k bps \\o/\n" +
"   / /__/ / / _// , _/ /|_/ /  vLink 1.359    \n" +
"  /____/_/ /___/_/|_/_/  /_/   617-555-1337   \n" +
"                                              \n" +
"Username: ian                                 \n" +
"Password: **********                          \n" +
"logging in....................                \n" +
"Welcome session b6623a0fcc38cf68              \n" +
"Type 'help' to get started                    \n" +
">");

(function() {
  window.addEventListener('keydown', function(e) {
    if (e.key.length === 1) term.addChar(e.key);
    else if (e.keyCode === 13) term.addChar('\n');
    else return;
    gl.bindBuffer(gl.ARRAY_BUFFER, geoBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, term.getGeoBuffer(), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, term.getCharBuffer(), gl.STATIC_DRAW);
  });
  window.focus();
})();

/**
 * Provides requestAnimationFrame in a cross browser way.
 * paulirish.com/2011/requestanimationframe-for-smart-animating/
 */
window.requestAnimationFrame = window.requestAnimationFrame || (function() {
  return window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback, element) {
      window.setTimeout(callback, 1000 / 60);
    };
})();

var canvas,
  gl,
  geoBuffer,
  charBuffer,
  charLocation,
  fontTex, fontTexLocation,
  vertex_shader, fragment_shader,
  termTex, termFrameBuf,
  currentProgram,
  geoLocation,
  timeLocation,
  screenSizeLocation,
  gridSizeLocation,
  parameters = {
    start_time: Date.now(),
    time: 0,
    screenWidth: 0,
    screenHeight: 0,
    gridWidth: term.width,
    gridHeight: term.height
  };

var image = new Image();
image.src = 'apple2font.png';
image.onload = function() {
  init();
  animate();
};

function init() {
  vertex_shader = document.getElementById('vs').textContent;
  fragment_shader = document.getElementById('fs').textContent;

  canvas = document.querySelector('canvas');

  try {
    gl = canvas.getContext('experimental-webgl');
  } catch (error) {}
  if (!gl) {
    throw "Cannot create WebGL context.";
  }

  geoBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, geoBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, term.getGeoBuffer(), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  charBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, term.getCharBuffer(), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Font image
  fontTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, fontTex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  gl.bindTexture(gl.TEXTURE_2D, null);

  // Create Program
  currentProgram = createProgram(vertex_shader, fragment_shader);
  timeLocation = gl.getUniformLocation(currentProgram, 'uTime');
  screenSizeLocation = gl.getUniformLocation(currentProgram, 'uScreenSize');
  gridSizeLocation = gl.getUniformLocation(currentProgram, 'uGridSize');
  fontTexLocation = gl.getUniformLocation(currentProgram, 'uFont');
  geoLocation = gl.getAttribLocation(currentProgram, 'aGeo');
  charLocation = gl.getAttribLocation(currentProgram, 'aChar');

  // Terminal framebuffer & texture
  termFrameBuf = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, termFrameBuf);
  termTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, termTex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1024, 1024, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, termTex, 0);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

}

function createProgram(vertex, fragment) {

  var program = gl.createProgram();

  var vs = createShader(vertex, gl.VERTEX_SHADER);
  var fs = createShader(fragment, gl.FRAGMENT_SHADER);

  if (vs == null || fs == null) return null;

  gl.attachShader(program, vs);
  gl.attachShader(program, fs);

  gl.deleteShader(vs);
  gl.deleteShader(fs);

  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {

    throw new Error("ERROR:\n" +
      "VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n" +
      "ERROR: " + gl.getError() + "\n" +
      "LOG: " + gl.getProgramInfoLog(program) + "\n\n" +
      "- Vertex Shader -\n" + vertex + "\n\n" +
      "- Fragment Shader -\n" + fragment);

    return null;

  }

  return program;

}

function createShader(src, type) {

  var shader = gl.createShader(type);

  gl.shaderSource(shader, src);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {

    throw new Error((type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT") + " SHADER:\n" + gl.getShaderInfoLog(shader));
    return null;

  }

  return shader;

}

function resize() {
  var r = window.devicePixelRatio || 1;
  var w = Math.floor(gl.canvas.clientWidth  * r);
  var h = Math.floor(gl.canvas.clientHeight * r);
  if (canvas.width != w || canvas.height != h) {
    canvas.width = parameters.screenWidth = w;
    canvas.height = parameters.screenHeight = h;
    gl.viewport(0, 0, w, h);
  }
}

function animate() {
  resize();
  render();
  requestAnimationFrame(animate);
}

function render() {

  if (!currentProgram) return;

  parameters.time = Date.now() - parameters.start_time;

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  gl.useProgram(currentProgram);
  gl.uniform1f(timeLocation, parameters.time / 1000);
  gl.uniform2f(screenSizeLocation, parameters.screenWidth, parameters.screenHeight);
  gl.uniform2f(gridSizeLocation, parameters.gridWidth, parameters.gridHeight);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, fontTex);
  gl.uniform1i(fontTexLocation, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, geoBuffer);
  gl.vertexAttribPointer(geoLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(geoLocation);

  gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
  gl.vertexAttribPointer(charLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(charLocation);

  gl.drawArrays(gl.TRIANGLES, 0, term.buffer.length * 3);

  gl.disableVertexAttribArray(geoLocation);
  gl.disableVertexAttribArray(charLocation);

}

</script>
</body>
</html>
