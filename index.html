<!doctype html>
<html dir="ltr" lang="en-US">
<head>
<title>langterm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<style type="text/css">
html, body {
  background: #222; color: #eee; margin: 0; overflow: hidden; width: 100%; height: 100%;
  background-image: url('term.jpg');
  background-size: cover;
  background-position: center;
}
canvas { width: 100%; height: 100%; }
</style>
</head>
<body>

<canvas></canvas>

<script src="gl-matrix-min.js"><</script>

<script id="post-vs" type="x-shader/vertex">
attribute vec3 aPosition;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;

void main(void) {
  gl_Position = vec4(aPosition, 1.0);
  vTexCoord = aTexCoord;
}
</script>

<script id="post-fs" type="x-shader/fragment">
uniform sampler2D uTermTex;
varying highp vec2 vTexCoord;

void main(void) {
  gl_FragColor = texture2D(uTermTex, vTexCoord);
  gl_FragColor.b += 0.2; // XXX
}
</script>

<script id="comp-vs" type="x-shader/vertex">
attribute vec3 aPosition;
attribute vec2 aTexCoord;
uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
varying vec2 vTexCoord;

void main(void) {
  gl_Position = uPMatrix * uMVMatrix * vec4(aPosition, 1.0);
  vTexCoord = aTexCoord;
}
</script>

<script id="comp-fs" type="x-shader/fragment">
uniform sampler2D uPostTex;
varying highp vec2 vTexCoord;

void main(void) {
  gl_FragColor = texture2D(uPostTex, vTexCoord);
  if (vTexCoord.x < 0.01 || vTexCoord.x > 0.99 || vTexCoord.y < 0.01 || vTexCoord.y > 0.99)
    gl_FragColor += 0.2;
}
</script>

<script id="term-vs" type="x-shader/vertex">
uniform float uTime;
uniform vec2 uScreenSize;
uniform vec2 uGridSize;
attribute vec2 aGeo;
attribute vec2 aChar;
varying vec2 vCharCoord;
varying vec2 vArea;
varying float vAttr;

const float ATTR_CURSOR = 1.0;
const float ATTR_INVERSE = 2.0;
const float ATTR_BLINK = 4.0;

const float PADDING = 0.01;

void main() {
  // Geometry looks like this:
  //
  // ---------.
  // |    |  /
  // |    | /
  // |____|/
  // |    /
  // |   /
  // |  /
  // | /
  // |/

  // Char is our character space triangle vertex. (0,0) means first col & row.
  float i = aGeo[0];
  float row = floor(i/uGridSize.x);
  float col = i - row * uGridSize.x;
  vec2 char = vec2(col, row);
  float k = aGeo[1];
  if (k == 1.0) char.x += 1.0;
  if (k == 2.0) char.y += 1.0;

  // Area is also a similar triangle, but used by the fragment shader.
  vArea = vec2(0.0, 0.0);
  if (k == 1.0) vArea.x += 2.0;
  if (k == 2.0) vArea.y += 2.0;

  // Pos converts the char coords to clip space.
  vec2 pos = char;
  if (k == 1.0) pos.x += 1.3; // 1.0 works but these values result in
  if (k == 2.0) pos.y += 0.7; // some better line spacing.
  pos = (pos / uGridSize * 2.0) - 1.0;
  pos *= (1.0 - PADDING * 2.0) + PADDING;
  pos.y *= -1.0;
  gl_Position = vec4(pos, 0, 1);

  // The second item of aChar is a bitmask of character attributes.
  vAttr = aChar[1];

  // Calculate the 128x128px (16x16 grid) Apple 2 sprite map coords.
  i = aChar[0] - 32.0;
  col = mod(i, 16.0) / 16.0;
  row = floor(i/16.0) / 16.0;
  // If this char is the cursor, make it blink the cursor symbol.
  if (mod(vAttr / ATTR_CURSOR, 2.0) >= 1.0 && mod(uTime*3.5, 2.0) <= 1.0) {
    col = 15.0/16.0;
    row = 5.0/16.0;
  }
  vCharCoord = vec2(col, row);
  // Remember, make a triangle, and make large enough to cover the character rectangle.
  if (k == 1.0) vCharCoord.x += 2.0/16.0;
  if (k == 2.0) vCharCoord.y += 2.0/16.0;
}
</script>

<script id="term-fs" type="x-shader/fragment">
uniform float uTime;
uniform sampler2D uFont;
varying vec2 vCharCoord;
varying vec2 vArea;
varying float vAttr;

const float ATTR_CURSOR = 1.0;
const float ATTR_INVERSE = 2.0;
const float ATTR_BLINK = 4.0;

const vec4 FG = vec4(.95, .45, .02, 1.0);

const float EPSILON = 0.000;

void main() {
  // Trim the triangle so we only draw the rectangle.
  // Without EPSILON we get a few gaps in inversed lines.
  if (vArea.x > 1.0 + EPSILON || vArea.y > 1.0 + EPSILON) discard;

  bool value = texture2D(uFont, vCharCoord).r >= 1.0;
  bool inverse = mod(vAttr / ATTR_INVERSE, 2.0) >= 1.0;
  if (value && inverse) discard;
  if (!value && !inverse) discard;

  gl_FragColor = FG;
}
</script>

<script>

var Terminal = (function() {

  function Terminal() {
    this.width = 60;
    this.height = 24;
    this.cursor = { x: 0, y: 0 };
    var a = this.width * this.height;
    this.buffer = new Array(a);
    this.attrs = new Array(a);
    this._charBuffer = new Float32Array(a * 6);
    this._geoBuffer = new Float32Array(a * 6);
    this.clear();
  }

  Terminal.ATTR_CURSOR = 1;
  Terminal.ATTR_INVERSE = 2;
  Terminal.ATTR_BLINK = 4;

  Terminal.prototype.clear = function() {
    this.cursor.x = 0;
    this.cursor.y = 0;
    for (var i = 0, len = this.buffer.length; i < len; i++) {
      this.buffer[i] = ' ';
      this.attrs[i] = 0;
    }
    this._dirty = true;
  };

  Terminal.prototype.addString = function(s, attrs) {
    var _this = this;
    s.split('').forEach(function(c) { _this.addChar(c, attrs); });
  };

  Terminal.prototype.addChar = function(c, attrs) {
    var i = this.cursor.y * this.width + this.cursor.x;
    if (c !== '\n') {
      this.buffer[i] = c;
      this.attrs[i] = attrs || 0;
    }
    if (c === '\n' || this.cursor.x >= this.width - 1) {
      this.cursor.x = 0;
      this.cursor.y++;
    } else {
      this.cursor.x++;
    }
    if (this.cursor.y >= this.height) {
      this.cursor.y--;
      var lastLine = this.buffer.length - this.width;
      for (i = 0, len = this.buffer.length; i < len; i++) {
        if (i < lastLine) {
          this.buffer[i] = this.buffer[i + this.width];
          this.attrs[i] = this.attrs[i + this.width];
        } else {
          this.buffer[i] = ' ';
          this.attrs[i] = 0;
        }
      }
    }
    this._dirty = true;
  };

  Terminal.prototype._update = function() {
    if (!this._dirty) return;
    for (var i = 0, len = this.buffer.length; i < len; i++) {
      var j = i * 6, c = this.buffer[i].charCodeAt(0), a = this.attrs[i];
      var y = Math.floor(i / this.width), x = i - y * this.width;
      if (this.cursor.x === x && this.cursor.y === y) a |= Terminal.ATTR_CURSOR;
      this._charBuffer[j+0] = c;
      this._charBuffer[j+1] = a;
      this._charBuffer[j+2] = c;
      this._charBuffer[j+3] = a;
      this._charBuffer[j+4] = c;
      this._charBuffer[j+5] = a;
      this._geoBuffer[j+0] = i;
      this._geoBuffer[j+1] = 0;
      this._geoBuffer[j+2] = i;
      this._geoBuffer[j+3] = 1;
      this._geoBuffer[j+4] = i;
      this._geoBuffer[j+5] = 2;
    }
  };

  Terminal.prototype.getCharBuffer = function() {
    this._update();
    return this._charBuffer;
  };

  Terminal.prototype.getGeoBuffer = function() {
    this._update();
    return this._geoBuffer;
  };

  Terminal.prototype.toString = function() {
    var out = new Array(this.buffer.length);
    for (var i = 0, len = this.buffer.length; i < len; i++) {
      out[i] = this.buffer[i] + (i !== 0 && i % this.width == 0 ? '\n' : '');
    }
    return out.join('');
  };

  return Terminal;

})();

var term = new Terminal();
term.addString(
"     __ _____________  __  ___                \n" +
"    / //_  __/ __/ _ \\/  |/  / 28.8k bps \\o/\n" +
"   / /__/ / / _// , _/ /|_/ /  vLink 1.359    \n" +
"  /____/_/ /___/_/|_/_/  /_/   617-555-1337   \n" +
"                                              \n" +
"Username: ian                                 \n" +
"Password: **********                          \n" +
"logging in....................                \n" +
"Welcome session b6623a0fcc38cf68              \n" +
"Type 'help' to get started                    \n" +
">");
//for (var i = 0; i < term.width * term.height - 2; i++) { term.addChar('#'); }

(function() {
  window.addEventListener('keydown', function(e) {
    if (e.key.length === 1) term.addChar(e.key);
    else if (e.keyCode === 13) term.addChar('\n');
    else return;
    gl.bindBuffer(gl.ARRAY_BUFFER, geoBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, term.getGeoBuffer(), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, term.getCharBuffer(), gl.STATIC_DRAW);
  });
  window.focus();
})();

/**
 * Provides requestAnimationFrame in a cross browser way.
 * paulirish.com/2011/requestanimationframe-for-smart-animating/
 */
window.requestAnimationFrame = window.requestAnimationFrame || (function() {
  return window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback, element) {
      window.setTimeout(callback, 1000 / 60);
    };
})();

var canvas,
  gl,
  geoBuffer,
  charBuffer,
  charLocation,
  fontTex, fontTexLocation,
  termTex, termFrameBuf,
  termProgram,
  geoLocation,
  timeLocation,
  screenSizeLocation,
  gridSizeLocation,
  compProgram,
  compPostTexLocation,
  compPositionBuffer, compPositionLocation,
  compTexCoordBuffer, compTexCoordLocation,
  compMVMatrix, compMVMatrixLocation,
  compPMatrix, compPMatrixLocation,
  postProgram,
  postFrameBuf, postTex, postTermTexLocation,
  postPositionBuffer, postPositionLocation,
  postTexCoordBuffer, postTexCoordLocation,
  parameters = {
    start_time: Date.now(),
    time: 0,
    screenWidth: 0,
    screenHeight: 0,
    gridWidth: term.width,
    gridHeight: term.height
  };

var image = new Image();
image.src = 'apple2font.png';
image.onload = function() {
  init();
  animate();
};

function init() {
  glMatrix.setMatrixArrayType(Float32Array);

  var UNIT_QUAD_GEO = new Float32Array([
     1.0,  1.0,  0.0,
    -1.0,  1.0,  0.0,
     1.0, -1.0,  0.0,
    -1.0, -1.0,  0.0
  ]);
  var UNIT_QUAT_COORDS = new Float32Array([
    1, 1,
    0, 1,
    1, 0,
    0, 0
  ]);

  var vs, fs;
  canvas = document.querySelector('canvas');

  try {
    gl = canvas.getContext('experimental-webgl');
  } catch (error) {}
  if (!gl) {
    throw "Cannot create WebGL context.";
  }

  // Terminal gemoetry buffer
  geoBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, geoBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, term.getGeoBuffer(), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Terminal character buffer
  charBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, term.getCharBuffer(), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Terminal font image
  fontTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, fontTex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  gl.bindTexture(gl.TEXTURE_2D, null);

  // Terminal shader
  vs = document.getElementById('term-vs').textContent;
  fs = document.getElementById('term-fs').textContent;
  termProgram = createProgram(vs, fs);
  timeLocation = gl.getUniformLocation(termProgram, 'uTime');
  screenSizeLocation = gl.getUniformLocation(termProgram, 'uScreenSize');
  gridSizeLocation = gl.getUniformLocation(termProgram, 'uGridSize');
  fontTexLocation = gl.getUniformLocation(termProgram, 'uFont');
  geoLocation = gl.getAttribLocation(termProgram, 'aGeo');
  charLocation = gl.getAttribLocation(termProgram, 'aChar');

  // Terminal framebuffer & texture
  termFrameBuf = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, termFrameBuf);
  termTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, termTex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1024, 1024, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, termTex, 0);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  // Post-process framebuffer & texture
  postFrameBuf = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, postFrameBuf);
  postTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, postTex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1024, 1024, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, postTex, 0);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  // Post-process geometry buffer
  postPositionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, postPositionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, UNIT_QUAD_GEO, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Post-process texture coordinate buffer
  postTexCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, postTexCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, UNIT_QUAT_COORDS, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Post-process shader
  vs = document.getElementById('post-vs').textContent;
  fs = document.getElementById('post-fs').textContent;
  postProgram = createProgram(vs, fs);
  postTermTexLocation = gl.getUniformLocation(postProgram, 'uTermTex');
  postPositionLocation = gl.getAttribLocation(postProgram, 'aPosition');
  postTexCoordLocation = gl.getAttribLocation(postProgram, 'aTexCoord');

  // Composition geometry buffer
  compPositionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, compPositionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, UNIT_QUAD_GEO, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Composition texture coordinate buffer
  compTexCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, compTexCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, UNIT_QUAT_COORDS, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Composition shader
  vs = document.getElementById('comp-vs').textContent;
  fs = document.getElementById('comp-fs').textContent;
  compProgram = createProgram(vs, fs);
  compMVMatrixLocation = gl.getUniformLocation(compProgram, 'uMVMatrix');
  compPMatrixLocation = gl.getUniformLocation(compProgram, 'uPMatrix');
  compPostTexLocation = gl.getUniformLocation(compProgram, 'uPostTex');
  compPositionLocation = gl.getAttribLocation(compProgram, 'aPosition');
  compTexCoordLocation = gl.getAttribLocation(compProgram, 'aTexCoord');

}

function createProgram(vertex, fragment) {
  var program = gl.createProgram();
  var preamble = '#ifdef GL_ES\nprecision highp float;\n#endif\n\n';
  var vs = createShader(preamble + vertex, gl.VERTEX_SHADER);
  var fs = createShader(preamble + fragment, gl.FRAGMENT_SHADER);

  if (vs == null || fs == null) return null;
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.deleteShader(vs);
  gl.deleteShader(fs);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error("ERROR:\n" +
      "VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n" +
      "ERROR: " + gl.getError() + "\n" +
      "LOG: " + gl.getProgramInfoLog(program) + "\n\n" +
      "- Vertex Shader -\n" + vertex + "\n\n" +
      "- Fragment Shader -\n" + fragment);
    return null;
  }

  return program;
}

function createShader(src, type) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error((type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT") + " SHADER:\n" + gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}

function resize() {
  var r = window.devicePixelRatio || 1;
  var w = Math.floor(gl.canvas.clientWidth  * r);
  var h = Math.floor(gl.canvas.clientHeight * r);
  if (canvas.width != w || canvas.height != h) {
    canvas.width = parameters.screenWidth = w;
    canvas.height = parameters.screenHeight = h;
  }
  compPMatrix = mat4.create();
  mat4.perspective(compPMatrix, Math.PI/4, w/h, .1, 100);
  compMVMatrix = mat4.create();
  var q = quat.create();
  quat.rotateY(q, q, glMatrix.toRadian(6));
  quat.rotateZ(q, q, glMatrix.toRadian(1));
  mat4.fromRotationTranslationScale(compMVMatrix, q, [0.20, 0.05, -4.2], [1.45, 1.05, 1]);
}

function animate() {
  resize();
  render();
  requestAnimationFrame(animate);
}

function render() {
  if (!termProgram) return;

  // Draw the terminal

  parameters.time = Date.now() - parameters.start_time;

  gl.bindFramebuffer(gl.FRAMEBUFFER, termFrameBuf);
  gl.viewport(0, 0, 1024, 1024);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.useProgram(termProgram);
  gl.uniform1f(timeLocation, parameters.time / 1000);
  gl.uniform2f(screenSizeLocation, parameters.screenWidth, parameters.screenHeight);
  gl.uniform2f(gridSizeLocation, parameters.gridWidth, parameters.gridHeight);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, fontTex);
  gl.uniform1i(fontTexLocation, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, geoBuffer);
  gl.vertexAttribPointer(geoLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(geoLocation);

  gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
  gl.vertexAttribPointer(charLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(charLocation);

  gl.drawArrays(gl.TRIANGLES, 0, term.buffer.length * 3);

  gl.disableVertexAttribArray(geoLocation);
  gl.disableVertexAttribArray(charLocation);

  gl.bindTexture(gl.TEXTURE_2D, termTex);
  gl.generateMipmap(gl.TEXTURE_2D);
  gl.bindTexture(gl.TEXTURE_2D, null);

  // Post-process the terminal

  gl.bindFramebuffer(gl.FRAMEBUFFER, postFrameBuf);
  gl.viewport(0, 0, 1024, 1024);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.useProgram(postProgram);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, termTex);
  gl.uniform1i(postTermTexLocation, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, postPositionBuffer);
  gl.vertexAttribPointer(postPositionLocation, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(postPositionLocation);

  gl.bindBuffer(gl.ARRAY_BUFFER, postTexCoordBuffer);
  gl.vertexAttribPointer(postTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(postTexCoordLocation);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  gl.bindTexture(gl.TEXTURE_2D, postTex);
  gl.generateMipmap(gl.TEXTURE_2D);
  gl.bindTexture(gl.TEXTURE_2D, null);

  gl.disableVertexAttribArray(postPositionLocation);
  gl.disableVertexAttribArray(postTexCoordLocation);

  // Composite the terminal

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.useProgram(compProgram);
  gl.uniformMatrix4fv(compMVMatrixLocation, false, compMVMatrix);
  gl.uniformMatrix4fv(compPMatrixLocation, false, compPMatrix);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, postTex);
  gl.uniform1i(compPostTexLocation, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, compPositionBuffer);
  gl.vertexAttribPointer(compPositionLocation, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(compPositionLocation);

  gl.bindBuffer(gl.ARRAY_BUFFER, compTexCoordBuffer);
  gl.vertexAttribPointer(compTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(compTexCoordLocation);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  gl.disableVertexAttribArray(compPositionLocation);
  gl.disableVertexAttribArray(compTexCoordLocation);

}

</script>
</body>
</html>
