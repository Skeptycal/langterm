<!doctype html>
<!--

     __ _____________  __  ___
    / //_  __/ __/ _ \/  |/  / 28.8k bps \o/
   / /__/ / / _// , _/ /|_/ /  vLink 1.359
  /____/_/ /___/_/|_/_/  /_/   617-555-1337

Username: ian
Password: **********
logging in....................
Welcome session b6623a0fcc38cf68
Type 'help' to get started
>

-->
<html dir="ltr" lang="en-US">
<head>
<title>langterm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<style type="text/css">
html, body { background: #333; color: #eee; margin: 0; overflow: hidden; width: 100%; height: 100%; }
canvas { width: 100%; height: 100%; }
</style>
</head>
<body>

<canvas></canvas>

<script src="gl-matrix-min.js"><</script>

<script id="vs" type="x-shader/vertex">
uniform vec2 uScreenSize;
uniform vec2 uGridSize;
attribute vec2 aPosition;
attribute float aChar;
varying vec2 vCharCoord;

const float padding = 0.1;

void main() {
  vec2 pos = aPosition;

  // Add padding
  pos = pos * (1.0 - padding * 2.0) + padding;

  // Convert to clip space
  pos = (pos / uGridSize * 2.0) - 1.0;
  pos.y = pos.y * -1.0;

  gl_Position = vec4(pos, 0, 1);

  // Calculate char position
  float i = aChar - 32.0;
  float u = mod(i, 10.0) / 10.0 - 0.01;
  float v = floor(i/10.0) / 10.0 - 0.01;
  vCharCoord = vec2(u + aPosition.x/10.0, v + aPosition.y/10.0);
}
</script>

<script id="fs" type="x-shader/fragment">
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform sampler2D uImage;
varying vec2 vCharCoord;

void main() {
  gl_FragColor = texture2D(uImage, vCharCoord);
}
</script>

<script>

/**
 * Provides requestAnimationFrame in a cross browser way.
 * paulirish.com/2011/requestanimationframe-for-smart-animating/
 */
window.requestAnimationFrame = window.requestAnimationFrame || (function() {
  return window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback, element) {
      window.setTimeout(callback, 1000 / 60);
    };
})();

var canvas,
  gl,
  buffer,
  charBuffer,
  charLocation,
  vertex_shader, fragment_shader,
  currentProgram,
  positionLocation,
  timeLocation,
  screenSizeLocation,
  gridSizeLocation,
  parameters = {
    start_time: new Date().getTime(),
    time: 0,
    screenWidth: 0,
    screenHeight: 0,
    gridWidth: 4,
    gridHeight: 2
  };

var image = new Image();
image.src = 'font.jpg';
image.onload = function() {
  init();
  animate();
};

function init() {
  vertex_shader = document.getElementById('vs').textContent;
  fragment_shader = document.getElementById('fs').textContent;

  canvas = document.querySelector('canvas');

  try {
    gl = canvas.getContext('experimental-webgl');
  } catch (error) {}
  if (!gl) {
    throw "Cannot create WebGL context.";
  }

  buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0, 0,   1, 0,   0, 1,
        1, 0,   0, 1,   1, 1,
  ]), gl.STATIC_DRAW);

  var message = "hello";
  charBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(
        [104.0, 104.0, 104.0, 104.0, 104.0, 104.0] // h
        //message.split('').map(function(c){ return c.charCodeAt(0); })
  ), gl.STATIC_DRAW);

  // Font image
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

  // Create Program
  currentProgram = createProgram(vertex_shader, fragment_shader);
  timeLocation = gl.getUniformLocation(currentProgram, 'time');
  screenSizeLocation = gl.getUniformLocation(currentProgram, 'uScreenSize');
  gridSizeLocation = gl.getUniformLocation(currentProgram, 'uGridSize');
  positionLocation = gl.getAttribLocation(currentProgram, 'aPosition');
  charLocation = gl.getAttribLocation(currentProgram, 'aChar');
}

function createProgram(vertex, fragment) {

  var program = gl.createProgram();

  var vs = createShader(vertex, gl.VERTEX_SHADER);
  var fs = createShader(fragment, gl.FRAGMENT_SHADER);

  if (vs == null || fs == null) return null;

  gl.attachShader(program, vs);
  gl.attachShader(program, fs);

  gl.deleteShader(vs);
  gl.deleteShader(fs);

  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {

    throw new Error("ERROR:\n" +
      "VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n" +
      "ERROR: " + gl.getError() + "\n" +
      "LOG: " + gl.getProgramInfoLog(program) + "\n\n" +
      "- Vertex Shader -\n" + vertex + "\n\n" +
      "- Fragment Shader -\n" + fragment);

    return null;

  }

  return program;

}

function createShader(src, type) {

  var shader = gl.createShader(type);

  gl.shaderSource(shader, src);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {

    throw new Error((type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT") + " SHADER:\n" + gl.getShaderInfoLog(shader));
    return null;

  }

  return shader;

}

function resizeCanvas(event) {
  if (canvas.width != canvas.clientWidth || canvas.height != canvas.clientHeight) {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    parameters.screenWidth = canvas.width;
    parameters.screenHeight = canvas.height;

    gl.viewport(0, 0, canvas.width, canvas.height);
  }
}

function animate() {
  resizeCanvas();
  render();
  requestAnimationFrame(animate);
}

function render() {

  if (!currentProgram) return;

  parameters.time = Date.now() - parameters.start_time;

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Load program into GPU
  gl.useProgram(currentProgram);

  // Set values to program variables
  gl.uniform1f(timeLocation, parameters.time / 1000);
  gl.uniform2f(screenSizeLocation, parameters.screenWidth, parameters.screenHeight);
  gl.uniform2f(gridSizeLocation, parameters.gridWidth, parameters.gridHeight);

  // Render geometry
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(positionLocation);

  gl.bindBuffer(gl.ARRAY_BUFFER, charBuffer);
  gl.vertexAttribPointer(charLocation, 1, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(charLocation);

  gl.drawArrays(gl.TRIANGLES, 0, 6);

  gl.disableVertexAttribArray(positionLocation);
  gl.disableVertexAttribArray(charLocation);

}

</script>
</body>
</html>
