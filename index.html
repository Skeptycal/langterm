<!doctype html>
<html dir="ltr" lang="en-US">
<head>
<title>langterm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<style type="text/css">
html, body { background: #333; color: #eee; margin: 0; overflow: hidden; width: 100%; height: 100%; }
canvas { width: 100%; height: 100%; }
</style>
</head>
<body>

<canvas></canvas>

<script src="gl-matrix-min.js"><</script>

<script id="vs" type="x-shader/vertex">
uniform vec2 screenSize;
uniform vec2 gridSize;
attribute vec2 position;

void main() {

  float padding = 0.1;

  // convert the position from pixels to 0.0 to W/H
  vec2 zeroToOne = position / gridSize;

  // convert from 0->1 to 0->2
  vec2 zeroToTwo = zeroToOne * 2.0;

  // convert from 0->2 to -1->+1 (clipspace)
  vec2 clipSpace = zeroToTwo - 1.0;

  // flip the y coords
  clipSpace.y = clipSpace.y * -1.0;

  gl_Position = vec4(clipSpace, 0, 1);

  //gl_Position = vec4(position, 1.0, 1.0);
}
</script>

<script id="fs" type="x-shader/fragment">
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;

void main() {
  //vec2 position = -1.0 + 2.0 * gl_FragCoord.xy / screenSize.xy;
  //float red = abs(sin(position.x * position.y + time / 5.0));
  //float green = abs(sin(position.x * position.y + time / 4.0));
  //float blue = abs(sin(position.x * position.y + time / 3.0));
  //gl_FragColor = vec4(red, green, blue, 1.0);
  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
</script>

<script>

/**
 * Provides requestAnimationFrame in a cross browser way.
 * paulirish.com/2011/requestanimationframe-for-smart-animating/
 */
window.requestAnimationFrame = window.requestAnimationFrame || (function() {
  return window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback, element) {
      window.setTimeout(callback, 1000 / 60);
    };
})();

var canvas,
  gl,
  buffer,
  vertex_shader, fragment_shader,
  currentProgram,
  positionLocation,
  timeLocation,
  screenSizeLocation,
  gridSizeLocation,
  parameters = {
    start_time: new Date().getTime(),
    time: 0,
    screenWidth: 0,
    screenHeight: 0,
    gridWidth: 4,
    gridHeight: 2
  };

init();
animate();

function init() {
  vertex_shader = document.getElementById('vs').textContent;
  fragment_shader = document.getElementById('fs').textContent;

  canvas = document.querySelector('canvas');

  try {
    gl = canvas.getContext('experimental-webgl');
  } catch (error) {}
  if (!gl) {
    throw "Cannot create WebGL context.";
  }

  buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0, 0,
        1, 0,
        0, 1
  ]), gl.STATIC_DRAW);

  // Create Program
  currentProgram = createProgram(vertex_shader, fragment_shader);
  timeLocation = gl.getUniformLocation(currentProgram, 'time');
  screenSizeLocation = gl.getUniformLocation(currentProgram, 'screenSize');
  gridSizeLocation = gl.getUniformLocation(currentProgram, 'gridSize');
  positionLocation = gl.getAttribLocation(currentProgram, 'position');
}

function createProgram(vertex, fragment) {

  var program = gl.createProgram();

  var vs = createShader(vertex, gl.VERTEX_SHADER);
  var fs = createShader(fragment, gl.FRAGMENT_SHADER);

  if (vs == null || fs == null) return null;

  gl.attachShader(program, vs);
  gl.attachShader(program, fs);

  gl.deleteShader(vs);
  gl.deleteShader(fs);

  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {

    throw new Error("ERROR:\n" +
      "VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n" +
      "ERROR: " + gl.getError() + "\n" +
      "LOG: " + gl.getProgramInfoLog(program) + "\n\n" +
      "- Vertex Shader -\n" + vertex + "\n\n" +
      "- Fragment Shader -\n" + fragment);

    return null;

  }

  return program;

}

function createShader(src, type) {

  var shader = gl.createShader(type);

  gl.shaderSource(shader, src);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {

    throw new Error((type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT") + " SHADER:\n" + gl.getShaderInfoLog(shader));
    return null;

  }

  return shader;

}

function resizeCanvas(event) {
  if (canvas.width != canvas.clientWidth || canvas.height != canvas.clientHeight) {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    parameters.screenWidth = canvas.width;
    parameters.screenHeight = canvas.height;

    gl.viewport(0, 0, canvas.width, canvas.height);
  }
}

function animate() {
  resizeCanvas();
  render();
  requestAnimationFrame(animate);
}

function render() {

  if (!currentProgram) return;

  parameters.time = Date.now() - parameters.start_time;

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Load program into GPU
  gl.useProgram(currentProgram);

  // Set values to program variables
  gl.uniform1f(timeLocation, parameters.time / 1000);
  gl.uniform2f(screenSizeLocation, parameters.screenWidth, parameters.screenHeight);
  gl.uniform2f(gridSizeLocation, parameters.gridWidth, parameters.gridHeight);

  // Render geometry
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(positionLocation);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  gl.disableVertexAttribArray(positionLocation);

}

</script>
</body>
</html>
